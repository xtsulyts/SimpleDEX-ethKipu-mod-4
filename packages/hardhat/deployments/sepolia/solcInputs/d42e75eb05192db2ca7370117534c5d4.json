{
  "language": "Solidity",
  "sources": {
    "contracts/SimpleDEX.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/*\r\n    * Interfaz estándar de ERC20:\r\n    * Define las funciones mínimas que un contrato de token ERC20 debe implementar, como:\r\n    * - transfer: para mover tokens entre cuentas.\r\n    * - approve y allowance: para gestionar permisos de gasto entre contratos o cuentas.\r\n    * - transferFrom: para transferir tokens usando la autorización previa mediante approve.\r\n    * \r\n    * totalSupply:\r\n     * - Devuelve la cantidad total de tokens emitidos por el contrato.\r\n     * - Incluye tanto los tokens en circulación como los que están retenidos en contratos o cuentas específicas.\r\n    * balanceOf:\r\n     * - Devuelve el balance actual de tokens de una cuenta específica.\r\n     * - Parámetro:\r\n     *      - account: Dirección de la cuenta cuyo balance se desea consultar.\r\n     * - Salida:\r\n     *      - uint256: Cantidad de tokens que posee la cuenta especificada.\r\n     * allowance:\r\n     * - Devuelve la cantidad de tokens que un propietario ha permitido que otro gastador utilice en su nombre.\r\n     * - Parámetros:\r\n     *      - owner: Dirección del propietario de los tokens.\r\n     *      - spender: Dirección de la cuenta autorizada para gastar los tokens.\r\n     * - Salida:\r\n     *      - uint256: Cantidad de tokens que el gastador tiene permiso para usar.\r\n    * Se utiliza esta interfaz para interactuar con los contratos de los tokens TokenA y TokenB.\r\n*/\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract SimpleDEX {\r\n\r\n    // Direcciones de los tokens que serán intercambiados en el DEX.\r\n    // Estas direcciones se establecen al momento de desplegar el contrato.\r\n    address public tokenA; //Direccion del token A\r\n    address public tokenB; //Direccion del token B\r\n\r\n    // Variables de estado que almacenan las reservas actuales de TokenA y TokenB en el pool.\r\n    uint256 public reserveA; //Reserva actual del token A en el pool.\r\n    uint256 public reserveB; //Reserva actual del token B en el pool.\r\n\r\n    /*\r\n    * Eventos para registrar las operaciones importantes:\r\n    * - LiquidityAdded: Emitido cuando se agrega liquidez al pool.\r\n    * - LiquidityRemoved: Emitido cuando se elimina liquidez del pool.\r\n    * - Swapped: Emitido cuando ocurre un intercambio de tokens.\r\n    * - Price: Emitido para registrar el precio actual de los tokens.\r\n    */\r\n\r\n    event LiquidityAdded(address indexed provider, uint256 amountA, uint256 amountB);\r\n    event LiquidityRemoved(address indexed provider, uint256 amountA, uint256 amountB);\r\n    event Swapped(address indexed swapper, address indexed tokenIn, uint256 amountIn, uint256 amountOut);\r\n    event Price(uint256 priceTokenA, uint256 priceTokenB);\r\n\r\n    /*\r\n    * Constructor:\r\n    * - Inicializa el contrato con las direcciones de TokenA y TokenB.\r\n    * - Valida que las direcciones de los tokens no sean la dirección cero.\r\n    */\r\n\r\n    constructor(address _tokenA, address _tokenB) {\r\n        require(_tokenA != address(0) && _tokenB != address(0), \"Direecion de token invalida\");\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n    }\r\n\r\n    /*\r\n    * addLiquidity:\r\n    * - Permite a los usuarios agregar liquidez al pool proporcionando una cantidad específica de TokenA y TokenB.\r\n    * - Las cantidades deben ser positivas y los tokens se transfieren desde el usuario al contrato.\r\n    * - Las reservas internas (reserveA y reserveB) se actualizan después de la transferencia.\r\n    * - Emite un evento LiquidityAdded con los detalles de la operación.\r\n    */\r\n    function addLiquidity(uint256 amountA, uint256 amountB) external {\r\n        require(amountA > 0 && amountB > 0, \"Las cantidades deben ser mayores a cero\");\r\n\r\n        // Transferencia de los tokens desde el proveedor al contrato.\r\n        IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);\r\n        IERC20(tokenB).transferFrom(msg.sender, address(this), amountB);\r\n\r\n        // Actualización de las reservas del pool.\r\n        reserveA += amountA;\r\n        reserveB += amountB;\r\n\r\n        // Registro del evento de adición de liquidez.\r\n        emit LiquidityAdded(msg.sender, amountA, amountB);\r\n    }\r\n\r\n    /*\r\n    * removeLiquidity:\r\n    * - Permite a los usuarios retirar liquidez del pool en forma de TokenA y TokenB.\r\n    * - Las cantidades a retirar deben ser menores o iguales a las reservas actuales.\r\n    * - Las reservas internas se reducen según las cantidades retiradas.\r\n    * - Los tokens se transfieren desde el contrato al usuario.\r\n    * - Emite un evento LiquidityRemoved con los detalles de la operación.\r\n    */\r\n    function removeLiquidity(uint256 amountA, uint256 amountB) external {\r\n        require(amountA > 0 && amountB > 0, \"Las cantidades deben ser mayores a cero\");\r\n        require(reserveA >= amountA && reserveB >= amountB, \"No hay suficiente liquidez para eliminar\");\r\n\r\n        // Reducción de las reservas del pool.\r\n        reserveA -= amountA;\r\n        reserveB -= amountB;\r\n\r\n        // Transferencia de los tokens al proveedor de liquidez.\r\n        IERC20(tokenA).transfer(msg.sender, amountA);\r\n        IERC20(tokenB).transfer(msg.sender, amountB);\r\n\r\n        // Registro del evento de eliminación de liquidez.\r\n        emit LiquidityRemoved(msg.sender, amountA, amountB);\r\n    }\r\n\r\n    /*\r\n    * swapAforB:\r\n    * - Permite a los usuarios intercambiar una cantidad de TokenA por TokenB.\r\n    * - Calcula la cantidad de TokenB que debe enviarse al usuario basado en la fórmula del producto constante:\r\n    *   (x + dx) * (y - dy) = x * y\r\n    *   Donde:\r\n    *     x = reserva actual de TokenA.\r\n    *     y = reserva actual de TokenB.\r\n    *     dx = cantidad de TokenA proporcionada por el usuario.\r\n    *     dy = cantidad de TokenB a enviar al usuario.\r\n    * - Actualiza las reservas del pool después del intercambio.\r\n    * - Emite un evento Swapped con los detalles de la operación.\r\n    */\r\n    function swapAforB(uint256 amountAIn) external returns (uint256 amountBOut) {\r\n        require(amountAIn > 0, \"El importe de entrada debe ser mayor a cero\");\r\n\r\n        // Cálculo de las nuevas reservas usando la fórmula del producto constante.\r\n        uint256 newReserveA = reserveA + amountAIn;\r\n        uint256 newReserveB = (reserveA * reserveB) / newReserveA;\r\n        amountBOut = reserveB - newReserveB;\r\n\r\n        require(amountBOut > 0, \"Cantidad de salida debe ser mayor a cero\");\r\n\r\n        // Transferencia del TokenA desde el usuario al contrato.\r\n        IERC20(tokenA).transferFrom(msg.sender, address(this), amountAIn);\r\n\r\n        // Transferencia del TokenB desde el contrato al usuario.\r\n        IERC20(tokenB).transfer(msg.sender, amountBOut);\r\n\r\n        // Actualización de las reservas.\r\n        reserveA = newReserveA;\r\n        reserveB = newReserveB;\r\n\r\n        emit Swapped(msg.sender, tokenA, amountAIn, amountBOut);\r\n    }\r\n\r\n    /*\r\n    * swapBforA:\r\n    * - Permite a los usuarios intercambiar una cantidad de TokenB por TokenA.\r\n    * - Aplica la fórmula del producto constante para determinar la cantidad de TokenA que se enviará al usuario:\r\n    *   (x - dx) * (y + dy) = x * y\r\n    *   Donde:\r\n    *     x = reserva actual de TokenA.\r\n    *     y = reserva actual de TokenB.\r\n    *     dy = cantidad de TokenB proporcionada por el usuario.\r\n    *     dx = cantidad de TokenA a enviar al usuario.\r\n    * - Actualiza las reservas del pool después del intercambio.\r\n    * - Emite un evento Swapped con los detalles de la operación.\r\n    */\r\n    function swapBforA(uint256 amountBIn) external returns (uint256 amountAOut) {\r\n        require(amountBIn > 0, \"El importe de entrada debe ser mayor a cero\");\r\n\r\n        // Cálculo de las nuevas reservas usando la fórmula del producto constante.\r\n        uint256 newReserveB = reserveB + amountBIn;\r\n        uint256 newReserveA = (reserveA * reserveB) / newReserveB;\r\n        amountAOut = reserveA - newReserveA;\r\n\r\n        require(amountAOut > 0, \"Cantidad de salida debe ser mayor a cero\");\r\n\r\n        // Transferencia del TokenB desde el usuario al contrato.\r\n        IERC20(tokenB).transferFrom(msg.sender, address(this), amountBIn);\r\n\r\n        // Transferencia del TokenA desde el contrato al usuario.\r\n        IERC20(tokenA).transfer(msg.sender, amountAOut);\r\n\r\n        // Actualización de las reservas.\r\n        reserveA = newReserveA;\r\n        reserveB = newReserveB;\r\n\r\n        // Registro del evento de intercambio.\r\n        emit Swapped(msg.sender, tokenB, amountBIn, amountAOut);\r\n    }\r\n\r\n    /*\r\n    * getPrice:\r\n    * - Devuelve el precio actual de un token en términos del otro token dentro del pool.\r\n    * - Calcula el precio utilizando las reservas actuales y ajustando con un factor de precisión (10^18) para evitar errores por decimales.\r\n    * - El precio de TokenA se calcula como: (reserveB * 10^18) / reserveA.\r\n    * - El precio de TokenB se calcula como: (reserveA * 10^18) / reserveB.\r\n    * - La función valida que la dirección proporcionada corresponda a uno de los tokens configurados en el contrato.\r\n    */\r\n    function getPrice(address _token) external view returns (uint256 price) {\r\n        require(_token == tokenA || _token == tokenB, \"Direccion de token invalida\");\r\n\r\n        if (_token == tokenA) {\r\n            price = (reserveB * 10**18) / reserveA;\r\n        } else {\r\n            price = (reserveA * 10**18) / reserveB;\r\n        }\r\n\r\n        return price;// Devuelve el precio calculado.\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}