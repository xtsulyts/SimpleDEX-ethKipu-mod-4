{
  "language": "Solidity",
  "sources": {
    "contracts/TokenA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n    Este contrato implementa un token ERC20 estándar llamado TokenA.\r\n    Proporciona las funcionalidades básicas del estándar ERC20, incluyendo\r\n    transferencia de tokens, aprobación de transferencias delegadas y una \r\n    función adicional para quemar tokens, lo cual reduce el suministro total.\r\n*/\r\ncontract TokenA {\r\n\r\n    /*\r\n    Evento Transfer:\r\n    Se emite cuando un token es transferido de una dirección a otra.\r\n    Los parámetros son:\r\n        - from: Dirección del remitente.\r\n        - to: Dirección del destinatario.\r\n        - value: Cantidad de tokens transferidos.\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /*\r\n    Evento Approval:\r\n    Se emite cuando un propietario aprueba a un tercero para gastar tokens en su nombre.\r\n    Los parámetros son:\r\n        - owner: Dirección del propietario de los tokens.\r\n        - spender: Dirección del tercero autorizado.\r\n        - value: Cantidad de tokens que el tercero puede gastar.\r\n    */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /* \r\n    Variables de estado para el contrato.\r\n        - name: Nombre del token, \"TokenA\".\r\n        - symbol: Símbolo del token, \"TKA\".\r\n        - decimals: Decimales del token (18).\r\n        - totalSupply: Suministro total de tokens en existencia.\r\n    */\r\n    string public name = \"TokenA\";\r\n    string public symbol = \"TKA\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n    Mapeos para el balance de tokens y las asignaciones de gasto:\r\n    - balances: Guarda el balance de cada dirección.\r\n    - allowances: Guarda la cantidad de tokens que un propietario permite que un tercero gaste.\r\n    */\r\n    mapping(address => uint256) private balances;\r\n    mapping(address => mapping(address => uint256)) private allowances;\r\n\r\n    /*\r\n    La dirección del owner del contrato, quien recibe el suministro inicial de tokens.\r\n    */\r\n    address public owner;\r\n\r\n    /*\r\n    El constructor inicializa el suministro de tokens.\r\n    - _initialSupply: El suministro inicial de tokens que el propietario recibirá.\r\n    Ajusta el suministro a los decimales y asigna el total al propietario.\r\n    Emite un evento de transferencia desde la dirección 0 al propietario.\r\n    */\r\n    constructor(uint256 _initialSupply) {\r\n        owner = msg.sender;\r\n        totalSupply = _initialSupply * 10 ** uint256(decimals); // Ajusta por los decimales\r\n        balances[owner] = totalSupply;\r\n        emit Transfer(address(0), owner, totalSupply);\r\n    }\r\n\r\n    /*\r\n    Función balanceOf:\r\n    Devueve el balance de tokens de una dirección.\r\n    - account: La dirección para la cual se consulta el saldo.\r\n    Retorna el balance de la dirección dada.\r\n    */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return balances[account];\r\n    }\r\n\r\n    /*\r\n    Función transfer:\r\n    Permite a un titular transferir tokens directamente a otra dirección.\r\n    - to: Dirección del destinatario.\r\n    - value: Cantidad de tokens a transferir.\r\n    Requiere que el saldo del remitente sea suficiente y la cantidad sea mayor a cero.\r\n    Emitirá un evento de transferencia.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        require(to != address(0), \"Direccion invalida\");\r\n        require(value > 0, \"La catidad debe se mayor a cero para tranferir \");\r\n        require(balances[msg.sender] >= value, \"Balance insuficiente\");\r\n\r\n        // Actualiza los balances\r\n        balances[msg.sender] -= value; // Restar tokens del remitente\r\n        balances[to] += value; // Emitir evento de transferencia\r\n\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Función approve:\r\n    Permite a un propietario autorizar a un tercero a gastar una cantidad específica de sus tokens.\r\n    - spender: Dirección del tercero autorizado.\r\n    - value: Cantidad de tokens que el tercero puede gastar.\r\n    Protege contra race conditions (condiciones de carrera) al asegurar que la asignación \r\n    anterior se haya establecido a cero antes de cambiar el valor.\r\n    Emitirá un evento de aprobación.\r\n    */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0), \"No se aprovo la direccion\");\r\n\r\n        // Protege contra race conditions\r\n        require(\r\n            allowances[msg.sender][spender] == 0 || value == 0,\r\n            \"La asignacion debe establecerce en cero antes de cambier de valor\"\r\n        );\r\n\r\n        allowances[msg.sender][spender] = value;\r\n\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Función allowance:\r\n    Devuelve cuántos tokens un tercero puede gastar en nombre del propietario.\r\n    - tokenOwner: Dirección del propietario de los tokens.\r\n    - spender: Dirección del tercero autorizado.\r\n    Retorna la cantidad de tokens que el tercero puede gastar.\r\n    */\r\n    function allowance(address tokenOwner, address spender) public view returns (uint256) {\r\n        return allowances[tokenOwner][spender];\r\n    }\r\n\r\n     /*\r\n    Función transferFrom:\r\n    Permite a un tercero transferir tokens de la cuenta de un propietario a otra cuenta.\r\n    - from: Dirección del propietario de los tokens.\r\n    - to: Dirección del destinatario de los tokens.\r\n    - value: Cantidad de tokens a transferir.\r\n    Requiere que el tercero tenga suficiente asignación y que el propietario tenga el saldo suficiente.\r\n    Emitirá un evento de transferencia.\r\n    */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(to != address(0), \"No se puede tranferir direccion de destinatario incorrecta\");\r\n        require(value > 0, \"La tranferencia tiene que ser mayor a cero\");\r\n        require(balances[from] >= value, \"No hay suficiente balance para la tranferencia\");\r\n        require(allowances[from][msg.sender] >= value, \"Se exedio la asignacion\");\r\n\r\n        // Actualiza los balances y la asignación permitida\r\n        balances[from] -= value;// Restar tokens del propietario\r\n        balances[to] += value;  // Añadir tokens al destinatario\r\n        allowances[from][msg.sender] -= value; // Reducir la asignación\r\n\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Función burn:\r\n    Permite a un titular quemar (destruir) una cantidad específica de sus tokens.\r\n    - amount: Cantidad de tokens a quemar.\r\n    Requiere que el titular tenga suficiente saldo y que la cantidad sea mayor a cero.\r\n    Emitirá un evento de transferencia desde el titular hacia la dirección 0 (quema).\r\n    */\r\n    function burn(uint256 amount) public returns (bool) {\r\n        require(balances[msg.sender] >= amount, \"Saldo insuficiente para quemar\");\r\n        require(amount > 0, \"El saldo debe ser mayo a cero para quemar\");\r\n\r\n        balances[msg.sender] -= amount; // Restar los tokens del titular\r\n        totalSupply -= amount; // Reducir el suministro total\r\n\r\n        emit Transfer(msg.sender, address(0), amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/TokenB.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\nEste contrato implementa un token ERC20 estándar llamado TokenB.\r\nProporciona las funcionalidades básicas del estándar ERC20, incluyendo\r\ntransferencia de tokens, aprobación de transferencias delegadas y una \r\nfunción adicional para quemar tokens, lo cual reduce el suministro total.\r\n*/\r\ncontract TokenB {\r\n    /*\r\n    Evento Transfer:\r\n    Se emite cuando un token es transferido de una dirección a otra.\r\n    Los parámetros son:\r\n        - from: Dirección del remitente.\r\n        - to: Dirección del destinatario.\r\n        - value: Cantidad de tokens transferidos.\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /*\r\n    Evento Approval:\r\n    Se emite cuando un propietario aprueba a un tercero para gastar tokens en su nombre.\r\n    Los parámetros son:\r\n        - owner: Dirección del propietario de los tokens.\r\n        - spender: Dirección del tercero autorizado.\r\n        - value: Cantidad de tokens que el tercero puede gastar.\r\n    */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /* \r\n    Variables de estado para el contrato.\r\n        - name: Nombre del token, \"TokenB\".\r\n        - symbol: Símbolo del token, \"TKB\".\r\n        - decimals: Decimales del token (18).\r\n        - totalSupply: Suministro total de tokens en existencia.\r\n    */\r\n    string public name = \"TokenB\";\r\n    string public symbol = \"TKB\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n    Mapeos para el balance de tokens y las asignaciones de gasto:\r\n    - balances: Guarda el balance de cada dirección.\r\n    - allowances: Guarda la cantidad de tokens que un propietario permite que un tercero gaste.\r\n    */\r\n    mapping(address => uint256) private balances;\r\n    mapping(address => mapping(address => uint256)) private allowances;\r\n\r\n    /*\r\n    La dirección del owner del contrato, quien recibe el suministro inicial de tokens.\r\n    */\r\n    address public owner;\r\n\r\n    /*\r\n    El constructor inicializa el suministro de tokens.\r\n    - _initialSupply: El suministro inicial de tokens que el propietario recibirá.\r\n    Ajusta el suministro a los decimales y asigna el total al propietario.\r\n    Emite un evento de transferencia desde la dirección 0 al propietario.\r\n    */\r\n    constructor(uint256 _initialSupply) {\r\n        owner = msg.sender;\r\n        totalSupply = _initialSupply * 10**uint256(decimals); // Ajusta por los decimales\r\n        balances[owner] = totalSupply;\r\n        emit Transfer(address(0), owner, totalSupply);\r\n    }\r\n\r\n    /*\r\n    Función balanceOf:\r\n    Devueve el balance de tokens de una dirección.\r\n    - account: La dirección para la cual se consulta el saldo.\r\n    Retorna el balance de la dirección dada.\r\n    */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return balances[account];\r\n    }\r\n\r\n    /*\r\n    Función transfer:\r\n    Permite a un titular transferir tokens directamente a otra dirección.\r\n    - to: Dirección del destinatario.\r\n    - value: Cantidad de tokens a transferir.\r\n    Requiere que el saldo del remitente sea suficiente y la cantidad sea mayor a cero.\r\n    Emitirá un evento de transferencia.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        require(to != address(0), \"No se puede transferir a la direccion cero\");\r\n        require(value > 0, \"No se puede transferir cero tokens\");\r\n        require(balances[msg.sender] >= value, \"Balance insuficiente\");\r\n\r\n        // Actualiza los balances\r\n        balances[msg.sender] -= value; // Restar tokens del remitente\r\n        balances[to] += value; // Emitir evento de transferencia\r\n\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Función approve:\r\n    Permite a un propietario autorizar a un tercero a gastar una cantidad específica de sus tokens.\r\n    - spender: Dirección del tercero autorizado.\r\n    - value: Cantidad de tokens que el tercero puede gastar.\r\n    Protege contra race conditions (condiciones de carrera) al asegurar que la asignación \r\n    anterior se haya establecido a cero antes de cambiar el valor.\r\n    Emitirá un evento de aprobación.\r\n    */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0), \"No se puede aprovar la direccion cero\");\r\n\r\n        // Protege contra race conditions\r\n        require(\r\n            allowances[msg.sender][spender] == 0 || value == 0,\r\n            \"La asigmacion debe establecerce cero antes de cambiar a un nuevo valor\"\r\n        );\r\n\r\n        allowances[msg.sender][spender] = value;\r\n\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Función allowance:\r\n    Devuelve cuántos tokens un tercero puede gastar en nombre del propietario.\r\n    - tokenOwner: Dirección del propietario de los tokens.\r\n    - spender: Dirección del tercero autorizado.\r\n    Retorna la cantidad de tokens que el tercero puede gastar.\r\n    */\r\n    function allowance(address tokenOwner, address spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowances[tokenOwner][spender];\r\n    }\r\n\r\n    /*\r\n    Función transferFrom:\r\n    Permite a un tercero transferir tokens de la cuenta de un propietario a otra cuenta.\r\n    - from: Dirección del propietario de los tokens.\r\n    - to: Dirección del destinatario de los tokens.\r\n    - value: Cantidad de tokens a transferir.\r\n    Requiere que el tercero tenga suficiente asignación y que el propietario tenga el saldo suficiente.\r\n    Emitirá un evento de transferencia.\r\n    */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public returns (bool) {\r\n        require(to != address(0), \"No se puede tranferir direccion de destinatario incorrecta\");\r\n        require(value > 0, \"El monto de la tranferencia debe ser mayora cero tokens\");\r\n        require(balances[from] >= value, \"Balance insuficiente\");\r\n        require(\r\n            allowances[from][msg.sender] >= value,\r\n            \"Se exedio la asignacion\"\r\n        );\r\n\r\n        // Actualiza los balances y la asignación permitida\r\n        balances[from] -= value; // Restar tokens del propietario\r\n        balances[to] += value; // Añadir tokens al destinatario\r\n        allowances[from][msg.sender] -= value; // Reducir la asignación\r\n\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Función burn:\r\n    Permite a un titular quemar (destruir) una cantidad específica de sus tokens.\r\n    - amount: Cantidad de tokens a quemar.\r\n    Requiere que el titular tenga suficiente saldo y que la cantidad sea mayor a cero.\r\n    Emitirá un evento de transferencia desde el titular hacia la dirección 0 (quema).\r\n    */\r\n    function burn(uint256 amount) public returns (bool) {\r\n        require(\r\n            balances[msg.sender] >= amount,\r\n            \"Balance insuficiente para quemar\"\r\n        );\r\n        require(amount > 0, \"La cantidad quemada debe ser mayor a cero\");\r\n\r\n        balances[msg.sender] -= amount; // Restar los tokens del titular\r\n        totalSupply -= amount; // Reducir el suministro total\r\n\r\n        emit Transfer(msg.sender, address(0), amount); // Emitir evento de transferencia para quemar\r\n        return true;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}